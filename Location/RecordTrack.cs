using Android.App;
using Android.Content;
using Android.Content.PM;
using Android.Content.Res;
using Android.Locations;
using Android.OS;
using Android.Runtime;
using Android.Views;
using Android.Widget;
using AndroidX.Lifecycle;
using Google.Android.Material.Navigation;
using GPXUtils;
using hajk.Data;
using hajk.Fragments;
using hajk.Models;
using Mapsui;
using Mapsui.Extensions;
using Mapsui.Layers;
using Mapsui.Nts;
using Mapsui.Nts.Extensions;
using Mapsui.Projections;
using Mapsui.Providers;
using Mapsui.Rendering.Skia;
using Mapsui.Styles;
using Mapsui.Tiling;
using Microsoft.Maui.ApplicationModel;
using Microsoft.Maui.Devices;
using Microsoft.Maui.Devices.Sensors;
using Microsoft.Maui.Storage;
using NetTopologySuite.Geometries;
using Serilog;
using SharpGPX;
using SharpGPX.GPX1_1;
using SharpGPX.GPX1_1.Topografix;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace hajk
{
    class RecordTrack
    {
        private static bool NotificationDialogActive = false; //Is notification dialog active or not when XTE
        public static GpxClass trackGpx = new();
        private static Timer? Timer_WarnIfOffRoute;
        private static GenericCollectionLayer<List<IFeature>>? trackLayer;

        public static void StartTrackTimer()
        {
            try
            {
                Preferences.Set("RecordingTrack", true);

                /**///Move to check when new location data is provided
                int freq_OffRoute_s = int.Parse(Preferences.Get("freq_s_OffRoute", Fragment_Preferences.freq_OffRoute_s.ToString()));
                Timer_WarnIfOffRoute = new Timer(new TimerCallback(CheckOffRouteEvent), null, 0, freq_OffRoute_s * 1000);

                //Enable the menu item
                AndroidX.AppCompat.Widget.Toolbar? toolbar = Platform.CurrentActivity?.FindViewById<AndroidX.AppCompat.Widget.Toolbar>(Resource.Id.toolbar);
                toolbar?.Menu?.FindItem(Resource.Id.action_clearmap).SetEnabled(true);

                //Update Menu Item Text
                NavigationView? nav = Platform.CurrentActivity.FindViewById<NavigationView>(Resource.Id.nav_view);
                nav?.Menu?.FindItem(Resource.Id.nav_recordtrack)
                    .SetTitle(Resource.String.Stop_Recording);

                //Enable the menu item for pause / resume
                nav?.Menu?.FindItem(Resource.Id.nav_PauseResumeRecordTrack)
                    .SetTitle(Resource.String.PauseRecord_Track)
                    .SetEnabled(true);

                //nav?.Invalidate();

                Log.Information("Create CheckPoint file");
                trackGpx.ToFile(Fragment_Preferences.CheckpointGPX);
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, $"RecordTrack - StartTrackTimer()");
            }
        }

        public static async Task<bool> EndTrackTimer()
        {
            try
            {
                Preferences.Set("RecordingTrack", false);

                //Stop the timers
                Timer_WarnIfOffRoute?.Dispose(); //Checking if OffRoute

                //Clear ActiveRoute
                MainActivity.ActiveRoute = null;

                //Update status
                Preferences.Set("RecordingTrack", false);

                //Reset the counter
                ElevationAnalyzer.Reset();

                Show_Dialog msg1 = new(Platform.CurrentActivity);
                if (await msg1.ShowDialog($"Track", $"Save Track ?", Android.Resource.Attribute.DialogIcon, false, Show_Dialog.MessageResult.YES, Show_Dialog.MessageResult.NO) == Show_Dialog.MessageResult.NO)
                {
                    return false;
                }

                string name = DateTime.Now.ToString("dd/MM/yyyy HH:mm");
                string? appname = Platform.CurrentActivity.Resources?.GetString(Resource.String.app_name);
                GpxClass track = new()
                {                    
                    Metadata = new metadataType()
                    {
                        author = new personType(appname),
                        name = name, /**///This should reflect the name of the route we're following, or a user selected name
                        desc = "Track generated by " + appname
                    },
                };

                track.Tracks.Add(new trkType()
                {
                    name = name,
                    trkseg = new trksegTypeCollection().AddItem(
                        new trksegType()
                        {
                            trkpt = trackGpx.Waypoints,
                        })
                });
                track.Metadata.bounds = track.GetBounds();

                //Calculate Distance
                float mapDistance_m = 0.0f;
                var p = new PositionHandler();
                for (int j = 1; j < track.Tracks[0].trkseg[0].trkpt.Count; j++)
                {
                    var p1 = new GPXUtils.Position((float)track.Tracks[0].trkseg[0].trkpt[j - 1].lat, (float)track.Tracks[0].trkseg[0].trkpt[j - 1].lon, 0, false, null);
                    var p2 = new GPXUtils.Position((float)track.Tracks[0].trkseg[0].trkpt[j].lat, (float)track.Tracks[0].trkseg[0].trkpt[j].lon, 0, false, null);
                    mapDistance_m += (float)p.CalculateDistance(p1, p2, DistanceType.Meters);
                }

                //Elevation data
                (int ascent, int descent) = Elevation.CalculateAscentDescent(track.Tracks[0]);

                //Naismith's Travel Time
                (int travel_hours, int travel_min) = Naismith.CalculateTime(mapDistance_m/1000, Fragment_Preferences.naismith_speed_kmh, ascent, descent);

                //Thumbnail
                string? ImageBase64String = DisplayMapItems.CreateThumbnail(GPXType.Track, track);

                //Add to routetrack DB
                GPXDataRouteTrack r = new()
                {
                    GPXType = GPXType.Track,
                    Name = name,
                    Distance = mapDistance_m / 1000,
                    Ascent = ascent,
                    Descent = descent,
                    Description = "Track generated by " + appname,
                    GPX = track.ToXml(),
                    ImageBase64String = ImageBase64String,
                    ShenandoahsScale = ShenandoahsHikingDifficulty.CalculateScale(mapDistance_m, ascent),
                    NaismithTravelTime = $"{string.Format("{0:D2}", travel_hours)}:{string.Format("{0:D2}", travel_min)}",
                    GPXStartLocation = $"{track.Tracks[0].trkseg[0].trkpt[0].lat.ToString(CultureInfo.InvariantCulture)},{track.Tracks[0].trkseg[0].trkpt[0].lon.ToString(CultureInfo.InvariantCulture)}",
                };
                await RouteDatabase.SaveRouteAsync(r);

                //Remove checkpoint file
                Serilog.Log.Verbose("Deleting checkpoint file");
                File.Delete(Fragment_Preferences.CheckpointGPX);
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, $"RecordTrack - SaveTrack()");
            }

            return true;
        }

        private static void CheckOffRouteEvent(object? state)
        {
            try
            {
                //Only if enabled
                if (Preferences.Get("EnableOffRouteWarning", Fragment_Preferences.EnableOffRouteWarning) == false)
                {
                    return;
                }

                //If not data, return
                if (MainActivity.ActiveRoute == null)
                {
                    return;
                }

                //If no location data, return
                var location = Geolocation.GetLastKnownLocationAsync().Result;
                if (location == null)
                {
                    return;
                }

                //Our location
                var pos_c = new GPXUtils.Position((float)location.Latitude, (float)location.Longitude, 0, false, null);

                //Distance to check
                int OffTrackDistanceWarning_m = int.Parse(Preferences.Get("OffTrackDistanceWarning_m", Fragment_Preferences.OffTrackDistanceWarning_m.ToString()));

                //Min distance position item
                int pos_index_a1 = 0;           //Index to position closest to GPS Position
                double pos_distance = 0.0f;     //Distance to position

                //Check current distance is less than OffTrackDistanceWarning_m against each waypoint in the route we are following
                var route = MainActivity.ActiveRoute.Routes[0];
                for (int i = 0; i < route.rtept.Count; i++)
                {
                    var lat = route.rtept[i].lat;
                    var lon = route.rtept[i].lon;

                    //Calculate Distance
                    var p = new PositionHandler();
                    var pos_a = new GPXUtils.Position((float)route.rtept[i].lat, (float)route.rtept[i].lon, 0, false, null);
                    double mapDistanceMeters = CrossTrackCalculations.CalculateDistance(pos_a, pos_c);

                    Log.Debug($"Location is: " + mapDistanceMeters.ToString("N2") + " meters from index:" + i.ToString());

                    if (mapDistanceMeters < (float)OffTrackDistanceWarning_m)
                    {
                        Log.Debug($"Location is less than - " + OffTrackDistanceWarning_m.ToString());
                        return;
                    }

                    //Get the waypoint we are closest to. We might need this later
                    if (mapDistanceMeters < pos_distance || pos_distance == 0)
                    {
                        Log.Debug($"Shortest Location is index: " + i.ToString());
                        pos_distance = mapDistanceMeters;
                        pos_index_a1 = i;
                    }
                }

                Log.Debug($"Location is more than - " + OffTrackDistanceWarning_m.ToString() + " from waypoints");

                //If waypoints are more than OffTrackDistanceWarning_m apart, we need to check distance from pos_c and the line between two paypoints
                Log.Debug($"Shortest Location Distance: " + pos_distance.ToString() + ", index: " + pos_index_a1.ToString() + ", Lat: " + route.rtept[pos_index_a1].lat.ToString() + ", Lon: " + route.rtept[pos_index_a1].lon.ToString());

                //Down Leg
                if (pos_index_a1 > 0)
                {
                    int pos_index_a2 = pos_index_a1 - 1;
                    bool AllOk = OffTrackXTECalculations(route.rtept[pos_index_a1], route.rtept[pos_index_a2], pos_c);
                    if (AllOk)
                    {
                        return;
                    }
                }

                //Up Leg
                if (pos_index_a1 < route.rtept.Count - 1)
                {
                    int pos_index_a2 = pos_index_a1 + 1;
                    bool AllOk = OffTrackXTECalculations(route.rtept[pos_index_a1], route.rtept[pos_index_a2], pos_c);
                    if (AllOk)
                    {
                        return;
                    }
                }

                //Supress notification for n min?
                if (NotificationDialogActive == false)
                {
                    NotificationDialogActive = true;

                    MainThread.BeginInvokeOnMainThread(async () =>
                    {
                        int OffTrackRouteSnooze_m = int.Parse(Preferences.Get("OffTrackRouteSnooze_m", Fragment_Preferences.OffRouteSnooze_m.ToString()));

                        //Get text to use
                        var a = Platform.CurrentActivity?.Resources?.GetString(Resource.String.OffRouteAlarm);
                        var b = Platform.CurrentActivity?.Resources?.GetString(Resource.String.IgnoreAlarmFor);
                        var c = Platform.CurrentActivity?.Resources?.GetString(Resource.String.Minutes);

                        Show_Dialog msg1 = new(Platform.CurrentActivity);
                        if (await msg1.ShowDialog(a, b + " " + OffTrackRouteSnooze_m.ToString() + " " + c, Android.Resource.Attribute.DialogIcon, false, Show_Dialog.MessageResult.YES, Show_Dialog.MessageResult.NO) == Show_Dialog.MessageResult.YES)
                        {
                            int freq_s = int.Parse(Preferences.Get("freq", Fragment_Preferences.freq_s.ToString()));
                            RecordTrack.Timer_WarnIfOffRoute.Change(OffTrackRouteSnooze_m * 60 * 1000, freq_s * 1000);
                        }
                        NotificationDialogActive = false;
                    });
                }

                //If get this far, vibrate the phone
                try
                {
                    var duration = TimeSpan.FromSeconds(3);
                    Vibration.Vibrate(duration);
                }
                catch (FeatureNotSupportedException ex)
                {
                    Log.Debug($"CheckOffRouteEvent() - Vibrate feature not supported on device: " + ex.ToString());
                }
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, $"RecordTrack - CheckOffRouteEvent()");
            }
        }

        private static bool OffTrackXTECalculations(wptType a, wptType b, GPXUtils.Position pos_c)
        {
            try
            {
                //Find distance from line made up of a and b
                var l = CrossTrackCalculations.CalculateCrossTrackDistance(a, b, pos_c);
                var c_E = l.Item1;
                var s_xt = l.Item2;

                //Distance to route to check
                int OffTrackDistanceWarning_m = int.Parse(Preferences.Get("OffTrackDistanceWarning_m", Fragment_Preferences.OffTrackDistanceWarning_m.ToString()));

                //If s_xt is greater than OffTrackDistanceWarning_m, we dont need to know if position is between A and B
                if (s_xt > (double)OffTrackDistanceWarning_m)
                {
                    return false;
                }

                //Find the position along the line. Note: This could be outside the a and b boundaries
                var pos_c_E = CrossTrackCalculations.CalculateCrossTrackPosition(a, b, pos_c, c_E);

                //Distance and location to point on ab
                Log.Debug($"Cross Track Distance: " + s_xt.ToString() + " m at location: " + pos_c_E.Latitude.ToString() + ", " + pos_c_E.Longitude.ToString());

                //Distance from a to b
                var s_ab = CrossTrackCalculations.CalculateDistance(a, b);
                Log.Debug($"Distance from A to B: " + s_ab.ToString() + " m");

                //Distance from a to intersection
                var s_a = CrossTrackCalculations.CalculateDistance(a, pos_c_E);
                Log.Debug($"Distance from A to Intersection: " + s_a.ToString() + " m");

                //Distance from b to intersection
                var s_b = CrossTrackCalculations.CalculateDistance(b, pos_c_E);
                Log.Debug($"Distance from B to Intersection: " + s_b.ToString() + " m");

                //Outside the boundaries of a and b
                if (s_b > s_ab || s_a > s_ab)
                {
                    return false;
                }
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, $"RecordTrack - OffTrackXTECalculations()");
                return false;
            }

            //All is ok
            return true;
        }

        public static void GetGPSLocationEvent(Android.Locations.Location location)
        {
            try
            {
                if (location == null)
                {
                    return;
                }

                //Return if not 0, 5, 10, 15, 20, ... 55 seconds and we have atleast 2 waypoints
                if ((DateTime.Now.Second % 5 != 0) && (trackGpx.Waypoints.Count >= 2))
                {
                    return;
                }

                //Log.Information($"Updated GPS Location - Lat: {location.Latitude:N5}, Lon: {location.Longitude:N5}, Speed: {location.Speed:N5}, Altitude: {location.Altitude:N2}, DateStamp: {location.Timestamp}");

                //Don't use data older than 10 seconds
                DateTime gpsUTCDateTime = DateTimeOffset.FromUnixTimeMilliseconds(location.Time).DateTime;
                if (gpsUTCDateTime < DateTime.UtcNow.AddSeconds(-10))
                {
                    Log.Debug($"Discarding Location Information - Too old: {gpsUTCDateTime}");
                    return;
                }

                //Don't use if insufficient accuracy
                if (location.Accuracy < 0)
                {
                    Log.Debug($"Discarding Location Information  - Insuficient accuracy: {location.Accuracy:N2}");
                    return;
                }

                //Don't use if insufficient accuracy
                if (location.Accuracy > 50)
                {
                    Log.Debug($"Discarding Location Information  - Insuficient accuracy: {location.Accuracy:N2}");
                    return;
                }

                //Don't use if speed is greater than 10m / s
                if (location.Speed > 10)
                {
                    Log.Debug($"Discarding Location Information  - Speed too great for walking: {location.Speed:N2}");
                    return;
                }

                wptType waypoint = new()
                {
                    lat = (decimal)location.Latitude,
                    lon = (decimal)location.Longitude,
                    ele = (decimal)ElevationAnalyzer.AddElevation(location.Altitude), //Smoothed
                    time = DateTime.Now,
                    timeSpecified = true,
                    eleSpecified = true,
                    cmt = location.Altitude.ToString(), //Raw elevation from GPS
                };

                //Don't use if distance covered is more than possible in the timeframe provided
                var previous_waypoint = trackGpx.Waypoints.LastOrDefault();
                if (previous_waypoint != null)
                {
                    var p1 = new GPXUtils.Position((float)previous_waypoint.lat, (float)previous_waypoint.lon, 0, false, null);
                    var p2 = new GPXUtils.Position((float)waypoint.lat, (float)waypoint.lon, 0, false, null);

                    float mapDistance_m = (float)new PositionHandler().CalculateDistance(p1, p2, DistanceType.Meters);
                    var DistanceToPrevious_m =  mapDistance_m;
                    TimeSpan timeLapse = waypoint.time - previous_waypoint.time;
                    var speed = mapDistance_m / timeLapse.TotalSeconds;

                    if (speed > 10)
                    {
                        Log.Debug($"Discarding Location Information  - Speed too great for walking: {speed:N2} (Distance: {mapDistance_m}m, Timespan: {timeLapse.TotalSeconds} seconds)");
                        return;
                    }
                }

                trackGpx.Waypoints.Add(waypoint);
                Log.Debug($"Recording has '{trackGpx.Waypoints.Count}' waypoints");

                //Save current GPX to disk as temp file, every 100 waypoints
                if (trackGpx.Waypoints.Count % 100 == 0)
                {
                    try
                    {
                        Serilog.Log.Information("Saving CheckPoint file");
                        trackGpx.ToFile(Fragment_Preferences.CheckpointGPX);
                    }
                    catch (Exception ex)
                    {
                        Serilog.Log.Error(ex, $"Failed to save checkpoint file, {Fragment_Preferences.CheckpointGPX}");
                    }
                }

                if (Preferences.Get("DrawTrackOnGui", Fragment_Preferences.DrawTrackOnGui_b))
                {
                    //Add tracking layer to map, if not already created
                    AddTrackingLayer();

                    //Add feature on layer
                    if (trackGpx.Waypoints.Count >= 2)
                    {
                        var a1 = trackGpx.Waypoints[trackGpx.Waypoints.Count - 1];
                        var b1 = trackGpx.Waypoints[trackGpx.Waypoints.Count - 2];
                        var a2 = SphericalMercator.FromLonLat((double)a1.lon, (double)a1.lat).ToCoordinate();
                        var b2 = SphericalMercator.FromLonLat((double)b1.lon, (double)b1.lat).ToCoordinate();

                        //Lines between waypoints
                        trackLayer?.Features.Add(new GeometryFeature 
                        {
                            Geometry = new LineString([a2, b2])
                        });

                        //Waypoints
                        var feature = new GeometryFeature { Geometry = b2.ToPoint() };
                        feature.Styles.Add(new SymbolStyle
                        {
                            SymbolScale = 0.7f,
                            MaxVisible = 3.0f,
                            MinVisible = 0.0f,
                            RotateWithMap = true,
                            SymbolRotation = 0,
                            SymbolType = SymbolType.Ellipse,
                            Fill = new Mapsui.Styles.Brush { FillStyle = FillStyle.Hollow, Color = Mapsui.Styles.Color.Transparent, Background = Mapsui.Styles.Color.Transparent },
                            Outline = new Pen { Color = Mapsui.Styles.Color.Red, Width = 1.0f },
                        });

                        trackLayer?.Features.Add(feature);
                        trackLayer?.DataHasChanged();
                    }
                }
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, $"RecordTrack - GetGPSLocationEvent()");
            }
        }

        private static void AddTrackingLayer()
        {
            try
            {
                if (Fragment_map.map.Layers.FindLayer(Fragment_Preferences.Layer_Track).FirstOrDefault() == null)
                {
                    trackLayer = new GenericCollectionLayer<List<IFeature>>
                    {
                        Name = Fragment_Preferences.Layer_Track,
                        Tag = Fragment_Preferences.Layer_Track,
                        Style = DisplayMapItems.CreateStyle("Red"),
                    };
                    Fragment_map.map.Layers.Add(trackLayer);
                }
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, $"RecordTrack - AddTrackingLayer()");
            }
        }

        public static void ShowRecordedTrack()
        {
            AddTrackingLayer();

            try
            {
                foreach (var it in trackGpx.Waypoints.Select((x, i) => new { Value = x, Index = i }))
                {
                    if (it.Index >= 1)
                    {
                        Serilog.Log.Information($"Index: {it.Index} of {trackGpx.Waypoints.Count - 1}");

                        var a1 = trackGpx.Waypoints[it.Index - 1];
                        var b1 = trackGpx.Waypoints[it.Index];
                        var a2 = SphericalMercator.FromLonLat((double)a1.lon, (double)a1.lat).ToCoordinate();
                        var b2 = SphericalMercator.FromLonLat((double)b1.lon, (double)b1.lat).ToCoordinate();

                        //Lines between waypoints
                        trackLayer?.Features.Add(new GeometryFeature
                        {
                            Geometry = new LineString([a2, b2])
                        });

                        //Waypoints
                        var feature = new GeometryFeature { Geometry = b2.ToPoint() };
                        feature.Styles.Add(new SymbolStyle
                        {
                            SymbolScale = 0.7f,
                            MaxVisible = 3.0f,
                            MinVisible = 0.0f,
                            RotateWithMap = true,
                            SymbolRotation = 0,
                            SymbolType = SymbolType.Ellipse,
                            Fill = new Mapsui.Styles.Brush { FillStyle = FillStyle.Hollow, Color = Mapsui.Styles.Color.Transparent, Background = Mapsui.Styles.Color.Transparent },
                            Outline = new Pen { Color = Mapsui.Styles.Color.Red, Width = 1.0f },
                        });

                        trackLayer?.Features.Add(feature);
                    }
                }

                trackLayer?.DataHasChanged();
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, $"RecordTrack - ¨ShowRecordedTrack()");
            }
        }

        public static void RestoreCheckPoint()
        {
            if (File.Exists(Fragment_Preferences.CheckpointGPX) == false)
                return;

            Task.Run(async () =>
            {
                Show_Dialog msg1 = new(Platform.CurrentActivity);
                if (await msg1.ShowDialog($"Recording", $"Load checkpoint file?", Android.Resource.Attribute.DialogIcon, false, Show_Dialog.MessageResult.YES, Show_Dialog.MessageResult.NO) == Show_Dialog.MessageResult.NO)
                {
                    Serilog.Log.Verbose("Deleting checkpoint file");
                    File.Delete(Fragment_Preferences.CheckpointGPX);
                }
                else
                {
                    string contents = File.ReadAllText(Fragment_Preferences.CheckpointGPX);
                    trackGpx = GpxClass.FromXml(contents);

                    StartTrackTimer();
                }
            });
        }
    }
}
