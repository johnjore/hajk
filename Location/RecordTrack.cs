using Android.App;
using Android.Content;
using Android.Locations;
using Android.OS;
using Android.Runtime;
using Android.Views;
using Android.Widget;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;
using System.Text;
using SharpGPX;
using SharpGPX.GPX1_1;
using SharpGPX.GPX1_1.Topografix;
using Serilog;
using hajk.Data;
using hajk.Models;
using hajk.Fragments;
using GPXUtils;
using Mapsui;
using Mapsui.Extensions;
using Mapsui.Nts;
using Mapsui.Nts.Extensions;
using Mapsui.Layers;
using Mapsui.Projections;
using Mapsui.Providers;
using Mapsui.Rendering.Skia;
using Mapsui.Styles;
using Mapsui.Tiling;
using NetTopologySuite.Geometries;
using Xamarin.Essentials;
using System.Collections.Immutable;
using Android.Content.PM;
using Android.Content.Res;
using Google.Android.Material.Navigation;

namespace hajk
{
    class RecordTrack
    {
        private static bool NotificationDialogActive = false; //Is notification dialog active or not when XTE
        public static GpxClass trackGpx = new();
        //public static Timer? Timer_Order;
        private static Timer? Timer_WarnIfOffRoute;
        private static GenericCollectionLayer<List<IFeature>>? trackLayer;

        public static void StartTrackTimer()
        {
            try
            {
                Preferences.Set("RecordingTrack", true);

                /**///Move to check when new location data is provided
                int freq_OffRoute_s = int.Parse(Preferences.Get("freq_s_OffRoute", Fragment_Preferences.freq_OffRoute_s.ToString()));
                Timer_WarnIfOffRoute = new Timer(new TimerCallback(CheckOffRouteEvent), null, 0, freq_OffRoute_s * 1000);

                //Update location marker with correct colour
                Location.UpdateLocationFeature();

                //Enable the menu item
                AndroidX.AppCompat.Widget.Toolbar? toolbar = Platform.CurrentActivity?.FindViewById<AndroidX.AppCompat.Widget.Toolbar>(Resource.Id.toolbar);
                toolbar?.Menu?.FindItem(Resource.Id.action_clearmap).SetEnabled(true);

                //Update Menu Item Text
                NavigationView? nav = Platform.CurrentActivity.FindViewById<NavigationView>(Resource.Id.nav_view);
                nav?.Menu?.FindItem(Resource.Id.nav_recordtrack)
                    .SetTitle(Resource.String.Stop_Recording);

                //Enable the menu item for pause / resume
                nav?.Menu?.FindItem(Resource.Id.nav_PauseResumeRecordTrack)
                    .SetTitle(Resource.String.PauseRecord_Track)
                    .SetEnabled(true);

                //nav?.Invalidate();
            }
            catch (Exception ex)
            {
                Log.Error(ex, $"RecordTrack - StartTrackTimer()");
            }
        }

        public static async void EndTrackTimer()
        {
            try
            {
                Preferences.Set("RecordingTrack", false);

                //Stop the timers
                Timer_WarnIfOffRoute?.Dispose(); //Checking if OffRoute

                //Clear ActiveRoute
                MainActivity.ActiveRoute = null;

                //Update status
                Preferences.Set("RecordingTrack", false);

                Show_Dialog msg1 = new(Platform.CurrentActivity);
                if (await msg1.ShowDialog($"Track", $"Save Track ?", Android.Resource.Attribute.DialogIcon, false, Show_Dialog.MessageResult.YES, Show_Dialog.MessageResult.NO) == Show_Dialog.MessageResult.NO)
                {
                    return;
                }

                string name = DateTime.Now.ToString("dd/MM/yyyy HH:mm");
                string? appname = Platform.CurrentActivity.Resources?.GetString(Resource.String.app_name);
                GpxClass track = new()
                {                    
                    Metadata = new metadataType()
                    {
                        author = new personType(appname),
                        name = name, /**///This should reflect the name of the route we're following, or a user selected name
                        desc = "Track generated by " + appname
                    },
                };

                if (await msg1.ShowDialog($"Track", $"Optimize Track ?", Android.Resource.Attribute.DialogIcon, false, Show_Dialog.MessageResult.YES, Show_Dialog.MessageResult.NO) == Show_Dialog.MessageResult.YES)
                {
                    trackGpx.Waypoints = GPX.GPXOptimize.OptimizePoints(trackGpx.Waypoints);
                }

                track.Tracks.Add(new trkType()
                {
                    name = name,
                    trkseg = new trksegTypeCollection().AddItem(
                        new trksegType()
                        {
                            trkpt = trackGpx.Waypoints
                        })
                });
                track.Metadata.bounds = track.GetBounds();

                //Calculate Distance
                float mapDistance_m = 0.0f;
                var p = new PositionHandler();
                for (int j = 1; j < track.Tracks[0].trkseg[0].trkpt.Count; j++)
                {
                    var p1 = new GPXUtils.Position((float)track.Tracks[0].trkseg[0].trkpt[j - 1].lat, (float)track.Tracks[0].trkseg[0].trkpt[j - 1].lon, 0);
                    var p2 = new GPXUtils.Position((float)track.Tracks[0].trkseg[0].trkpt[j].lat, (float)track.Tracks[0].trkseg[0].trkpt[j].lon, 0);
                    mapDistance_m += (float)p.CalculateDistance(p1, p2, DistanceType.Meters);
                }

                //Add to routetrack DB
                GPXDataRouteTrack r = new()
                {
                    GPXType = GPXType.Track,
                    Name = name,
                    Distance = mapDistance_m / 1000,
                    Ascent = 0, /**///Fix this
                    Descent = 0, /**///Fix this
                    Description = "Track generated by hajk",
                    GPX = track.ToXml(),
                };
                RouteDatabase.SaveRouteAsync(r).Wait();
            }
            catch (Exception ex)
            {
                Log.Error(ex, $"RecordTrack - SaveTrack()");
            }
        }

        private static void CheckOffRouteEvent(object? state)
        {
            try
            {
                //Only if enabled
                if (Preferences.Get("EnableOffRouteWarning", Fragment_Preferences.EnableOffRouteWarning) == false)
                {
                    return;
                }

                //If not data, return
                if (MainActivity.ActiveRoute == null)
                {
                    return;
                }

                //If no location data, return
                var location = Geolocation.GetLastKnownLocationAsync().Result;
                if (location == null)
                {
                    return;
                }

                //Our location
                var pos_c = new GPXUtils.Position((float)location.Latitude, (float)location.Longitude, 0);

                //Distance to check
                int OffTrackDistanceWarning_m = int.Parse(Preferences.Get("OffTrackDistanceWarning_m", Fragment_Preferences.OffTrackDistanceWarning_m.ToString()));

                //Min distance position item
                int pos_index_a1 = 0;           //Index to position closest to GPS Position
                double pos_distance = 0.0f;     //Distance to position

                //Check current distance is less than OffTrackDistanceWarning_m against each waypoint in the route we are following
                var route = MainActivity.ActiveRoute.Routes[0];
                for (int i = 0; i < route.rtept.Count; i++)
                {
                    var lat = route.rtept[i].lat;
                    var lon = route.rtept[i].lon;

                    //Calculate Distance
                    var p = new PositionHandler();
                    var pos_a = new GPXUtils.Position((float)route.rtept[i].lat, (float)route.rtept[i].lon, 0);
                    double mapDistanceMeters = CrossTrackCalculations.CalculateDistance(pos_a, pos_c);

                    Log.Debug($"Location is: " + mapDistanceMeters.ToString("N2") + " meters from index:" + i.ToString());

                    if (mapDistanceMeters < (float)OffTrackDistanceWarning_m)
                    {
                        Log.Debug($"Location is less than - " + OffTrackDistanceWarning_m.ToString());
                        return;
                    }

                    //Get the waypoint we are closest to. We might need this later
                    if (mapDistanceMeters < pos_distance || pos_distance == 0)
                    {
                        Log.Debug($"Shortest Location is index: " + i.ToString());
                        pos_distance = mapDistanceMeters;
                        pos_index_a1 = i;
                    }
                }

                Log.Debug($"Location is more than - " + OffTrackDistanceWarning_m.ToString() + " from waypoints");

                //If waypoints are more than OffTrackDistanceWarning_m apart, we need to check distance from pos_c and the line between two paypoints
                Log.Debug($"Shortest Location Distance: " + pos_distance.ToString() + ", index: " + pos_index_a1.ToString() + ", Lat: " + route.rtept[pos_index_a1].lat.ToString() + ", Lon: " + route.rtept[pos_index_a1].lon.ToString());

                //Down Leg
                if (pos_index_a1 > 0)
                {
                    int pos_index_a2 = pos_index_a1 - 1;
                    bool AllOk = OffTrackXTECalculations(route.rtept[pos_index_a1], route.rtept[pos_index_a2], pos_c);
                    if (AllOk)
                    {
                        return;
                    }
                }

                //Up Leg
                if (pos_index_a1 < route.rtept.Count - 1)
                {
                    int pos_index_a2 = pos_index_a1 + 1;
                    bool AllOk = OffTrackXTECalculations(route.rtept[pos_index_a1], route.rtept[pos_index_a2], pos_c);
                    if (AllOk)
                    {
                        return;
                    }
                }

                //Supress notification for n min?
                if (NotificationDialogActive == false)
                {
                    NotificationDialogActive = true;

                    MainThread.BeginInvokeOnMainThread(async () =>
                    {
                        int OffTrackRouteSnooze_m = int.Parse(Preferences.Get("OffTrackRouteSnooze_m", Fragment_Preferences.OffRouteSnooze_m.ToString()));

                        //Get text to use
                        var a = Platform.CurrentActivity?.Resources?.GetString(Resource.String.OffRouteAlarm);
                        var b = Platform.CurrentActivity?.Resources?.GetString(Resource.String.IgnoreAlarmFor);
                        var c = Platform.CurrentActivity?.Resources?.GetString(Resource.String.Minutes);

                        Show_Dialog msg1 = new(Platform.CurrentActivity);
                        if (await msg1.ShowDialog(a, b + " " + OffTrackRouteSnooze_m.ToString() + " " + c, Android.Resource.Attribute.DialogIcon, false, Show_Dialog.MessageResult.YES, Show_Dialog.MessageResult.NO) == Show_Dialog.MessageResult.YES)
                        {
                            int freq_s = int.Parse(Preferences.Get("freq", Fragment_Preferences.freq_s.ToString()));
                            RecordTrack.Timer_WarnIfOffRoute.Change(OffTrackRouteSnooze_m * 60 * 1000, freq_s * 1000);
                        }
                        NotificationDialogActive = false;
                    });
                }

                //If get this far, vibrate the phone
                try
                {
                    var duration = TimeSpan.FromSeconds(3);
                    Vibration.Vibrate(duration);
                }
                catch (FeatureNotSupportedException ex)
                {
                    Log.Debug($"CheckOffRouteEvent() - Vibrate feature not supported on device: " + ex.ToString());
                }
            }
            catch (Exception ex)
            {
                Log.Error(ex, $"RecordTrack - CheckOffRouteEvent()");
            }
        }

        private static bool OffTrackXTECalculations(wptType a, wptType b, GPXUtils.Position pos_c)
        {
            try
            {
                //Find distance from line made up of a and b
                var l = CrossTrackCalculations.CalculateCrossTrackDistance(a, b, pos_c);
                var c_E = l.Item1;
                var s_xt = l.Item2;

                //Distance to route to check
                int OffTrackDistanceWarning_m = int.Parse(Preferences.Get("OffTrackDistanceWarning_m", Fragment_Preferences.OffTrackDistanceWarning_m.ToString()));

                //If s_xt is greater than OffTrackDistanceWarning_m, we dont need to know if position is between A and B
                if (s_xt > (double)OffTrackDistanceWarning_m)
                {
                    return false;
                }

                //Find the position along the line. Note: This could be outside the a and b boundaries
                var pos_c_E = CrossTrackCalculations.CalculateCrossTrackPosition(a, b, pos_c, c_E);

                //Distance and location to point on ab
                Log.Debug($"Cross Track Distance: " + s_xt.ToString() + " m at location: " + pos_c_E.Latitude.ToString() + ", " + pos_c_E.Longitude.ToString());

                //Distance from a to b
                var s_ab = CrossTrackCalculations.CalculateDistance(a, b);
                Log.Debug($"Distance from A to B: " + s_ab.ToString() + " m");

                //Distance from a to intersection
                var s_a = CrossTrackCalculations.CalculateDistance(a, pos_c_E);
                Log.Debug($"Distance from A to Intersection: " + s_a.ToString() + " m");

                //Distance from b to intersection
                var s_b = CrossTrackCalculations.CalculateDistance(b, pos_c_E);
                Log.Debug($"Distance from B to Intersection: " + s_b.ToString() + " m");

                //Outside the boundaries of a and b
                if (s_b > s_ab || s_a > s_ab)
                {
                    return false;
                }
            }
            catch (Exception ex)
            {
                Log.Error(ex, $"RecordTrack - OffTrackXTECalculations()");
                return false;
            }

            //All is ok
            return true;
        }

        public static void GetGPSLocationEvent(Android.Locations.Location location)
        {
            if (location == null)
            {
                return;
            }

            if ((DateTime.Now.Second % 5 != 0) && (trackGpx.Waypoints.Count >= 2))
            {
                return;
            }

            //Log.Information($"Updated GPS Location - Lat: {location.Latitude:N5}, Lon: {location.Longitude:N5}, Speed: {location.Speed:N5}, Altitude: {location.Altitude:N2}, DateStamp: {location.Timestamp}");

            //Don't use data older than 10 seconds
            DateTime gpsUTCDateTime = DateTimeOffset.FromUnixTimeMilliseconds(location.Time).DateTime;
            if (gpsUTCDateTime < DateTime.UtcNow.AddSeconds(-10))
            {
                Log.Debug($"Discarding Location Information - Too old: {gpsUTCDateTime}");
                return;
            }

            //Don't use if insufficient accuracy
            if (location.Accuracy < 0)
            {
                Log.Debug($"Discarding Location Information  - Insuficient accuracy: {location.Accuracy:N2}");
                return;
            }

            //Don't use if insufficient accuracy
            if (location.Accuracy > 50)
            {
                Log.Debug($"Discarding Location Information  - Insuficient accuracy: {location.Accuracy:N2}");
                return;
            }

            //Don't use if speed is greater than 10m / s
            if (location.Speed > 10)
            {
                Log.Debug($"Discarding Location Information  - Speed too great for walking: {location.Speed:N2}");
                return;
            }

            try
            {
                wptType waypoint = new()
                {
                    lat = (decimal)location.Latitude,
                    lon = (decimal)location.Longitude,
                    ele = (decimal)location.Altitude,
                    time = DateTime.Now,
                    timeSpecified = true,
                    eleSpecified = true,
                };

                trackGpx.Waypoints.Add(waypoint);
                Log.Debug($"Recording has '{trackGpx.Waypoints.Count}' waypoints");

                if (Preferences.Get("DrawTrackOnGui", Fragment_Preferences.DrawTrackOnGui_b))
                {
                    //Add tracking layer to map
                    if (Fragment_map.map.Layers.FindLayer("tracklayer".ToLower()).FirstOrDefault() == null)
                    {
                        trackLayer = new GenericCollectionLayer<List<IFeature>>
                        {
                            Name = "tracklayer".ToLower(),
                            Style = Import.CreateStyle("Red"),
                        };
                        Fragment_map.map.Layers.Add(trackLayer);
                    }

                    //Add feature on layer
                    if (trackGpx.Waypoints.Count >= 2)
                    {
                        var a1 = trackGpx.Waypoints[trackGpx.Waypoints.Count - 1];
                        var b1 = trackGpx.Waypoints[trackGpx.Waypoints.Count - 2];
                        var a2 = SphericalMercator.FromLonLat((double)a1.lon, (double)a1.lat).ToCoordinate();
                        var b2 = SphericalMercator.FromLonLat((double)b1.lon, (double)b1.lat).ToCoordinate();

                        //Lines between waypoints
                        trackLayer?.Features.Add(new GeometryFeature 
                        {
                            Geometry = new LineString([a2, b2])
                        });

                        //Waypoints
                        var feature = new GeometryFeature { Geometry = b2.ToPoint() };
                        feature.Styles.Add(new SymbolStyle
                        {
                            SymbolScale = 0.7f,
                            MaxVisible = 10.0f,
                            MinVisible = 0.0f,
                            RotateWithMap = true,
                            SymbolRotation = 0,
                            SymbolType = SymbolType.Ellipse,
                            Fill = new Brush { FillStyle = FillStyle.Dotted, Color = Color.Transparent, Background = Color.Transparent },
                            Outline = new Pen { Color = Color.Red, Width = 1.0f },
                        });

                        trackLayer?.Features.Add(feature);
                        trackLayer?.DataHasChanged();
                    }
                }
            }
            catch (Exception ex)
            {
                Log.Error(ex, $"RecordTrack - GetGPSLocationEvent()");
            }
        }
    }
}
